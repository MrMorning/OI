\newproblem{83E. Two Subsequences}
\begin{prob}
	定义一个函数$f$：
	\begin{itemize}
		\item $f(\text{空串})=\text{空串}$
		\item $f(s) = s$
		\item $f(s_1, s_2) = \text{最短字符串，前缀为$s_1$，后缀为$s_2$}$. 
		\item $f(a_1, a_2, \cdots, a_n) = f(f(a_1, a_2, a_n - 1), a_n)$.
	\end{itemize}
	给定等长字符串序列$a_1 \cdots a_n$，
	需要将其分成两个子序列$s_1,s_2$，使得
	$|f(s_1)|+|f(s_2)|$最小。$n \le 10^5$
	，字符串为01串，且长度$ \le 20$。
\end{prob}

\begin{sol}
	考虑一个暴力的dp：$f[i][j]$
	表示到了第$i$个字符串，另
	一个序列以第$j$个字符串结尾。转移枚举
	第$i+1$个字符串是接到哪个序列上去。尽管
	转移为$O(1)$，但光状态就是$O(n^2)$。于
	是想办法简化状态。可以设$f[i]$表示$i$与$i+1$属
	于不同序列的答案。那么转移就需要枚举一段区间
	：$f[i]=\min\{f[j]+w[j+1][i]-g(j,i+1)\}$，其中
	$w[l][r]$表示将$l$到$r$的字符串压缩后的长度，
	$g(i,j)$表示将第$i$和第$j$个字符串接起来节省
	的长度。进一步观察可以发现，$g(j,i+1)$的取
	值只有20种。故可以枚举$j$与$i+1$的公共长度
	，用位运算来记录后缀为某个串的答案。于是整个
	算法复杂度只有$O(20n+2^{20})$。
\end{sol}
