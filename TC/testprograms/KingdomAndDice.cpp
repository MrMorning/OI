#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <cstring>
#define FOREACH(I, C) for(__typeof((C).begin()) I = (C).begin(); I != (C).end(); I++)

using namespace std;
typedef long long ll;

const int kInf = 0x3f3f3f3f;
const int kVMax = 3000;
const double kEps = 1e-9;

int sgn(double x) {
	if ( fabs(x) < kEps ) return 0;
	if ( x > 0 ) return 1;
	return 0;
}

class KingdomAndDice {
	public:
		int n;
		int obj[kVMax], nObj;
		int f[kVMax];
		double newFairness(vector <int> firstDie, vector <int> secondDie, int X) {
			sort(secondDie.begin(), secondDie.end());
			n = firstDie.size();

			double coef = 0;
			int freeCnt = n;
			for ( int i = 0; i < n; i ++ )
				if ( firstDie[i] != 0 ) {
					freeCnt--;
					int cnt = 0;
					for ( int j = 0; j < n; j ++ )
						cnt += firstDie[i] > secondDie[j];
					coef += cnt;
				}

			for ( int i = 0; i <= n; i ++ ) {
				int m, l, r;
				if ( i == 0 ) m = kInf;
				else if ( i == n ) m = X - secondDie[i-1], l = secondDie[i-1] + 1, r = X;
				else m = secondDie[i] - secondDie[i-1] - 1, l = secondDie[i-1] + 1, r = secondDie[i]-1;

				if ( i > 0 ) {
					for ( int j = 0; j < n; j ++ )
						if ( firstDie[j] != 0 && l <= firstDie[j] && firstDie[j] <= r )
							m --;
				}
				m = min(m, 50);
				while ( m -- )
					obj[nObj++] = i;
			}

			memset(f, 0x3f, sizeof(f));
			f[0] = 0;
			for ( int i = 0; i < nObj; i ++ ) {
				for ( int j = kVMax-1; j >= obj[i]; j -- )
					f[j] = min(f[j], f[j - obj[i]] + 1);
			}

			double ansBest = 0, ansDiff = 1e100;
			for ( int j = 0; j < kVMax; j ++ ) 
				if ( f[j] <= freeCnt ) {
					double tmp = fabs((double)(j + coef) / (n * n) - 0.5);
					if ( sgn(ansDiff - tmp) > 0 )
						ansDiff = tmp, ansBest = (double)(j + coef) / (n * n);
				}
			return ansBest;
		}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, int p2, bool hasAnswer, double p3) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << p2;
	cout << "]" << endl;
	KingdomAndDice *obj;
	double answer;
	obj = new KingdomAndDice();
	clock_t startTime = clock();
	answer = obj->newFairness(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = fabs(p3 - answer) <= 1e-9 * max(1.0, fabs(p3));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <int> p0;
	vector <int> p1;
	int p2;
	double p3;

	{
		// ----- test 0 -----
		int t0[] = {0,2,7,0};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = {6,3,8,10};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		p2 = 12;
		p3 = 0.4375;
		all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	{
		// ----- test 1 -----
		int t0[] = {0,2,7,0};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = {6,3,8,10};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		p2 = 10;
		p3 = 0.375;
		all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		int t0[] = {0,0};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = {5,8};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		p2 = 47;
		p3 = 0.5;
		all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		int t0[] = {19,50,4};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = {26,100,37};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		p2 = 1000;
		p3 = 0.2222222222222222;
		all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	{
		// ----- test 4 -----
		int t0[] = {2008566, 0, 0, 0, 0, 0, 0, 0, 6722285, 64815398, 0, 0, 0, 0, 8453367, 0, 0, 0, 16457963, 80358931, 14923697, 0, 0, 14404974, 0, 11768058, 0, 17294411, 0, 0, 0, 36780774, 0, 0, 0, 50237482, 0, 46033881, 0, 0, 0, 0, 0, 0, 0, 0, 61722499, 0, 44999317};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		int t1[] = {2869819, 1020553, 3369147, 30844016, 7419899, 2776614, 10678463, 27774202, 80187785, 36564173, 19872355, 15683121, 21421829, 32729186, 65920602, 33737021, 43144319, 18882934, 44210279, 18790055, 465938, 71141498, 21220980, 51512809, 47629131, 27680536, 26360331, 27175145, 62945786, 4717762, 61279397, 65815604, 77019734, 64648543, 3588072, 2263148, 67425156, 3371470, 19142285, 54541392, 39935642, 28119575, 70224512, 50462406, 49953696, 53968629, 73304363, 10921531, 61956498};
		p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
		p2 = 82176484;
		p3 = 0.49;
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
