#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <cassert>
#include <cstring>
#define FOREACH(I, C) for(__typeof((C).begin()) I = (C).begin(); I != (C).end(); I++)

using namespace std;
typedef long long ll;

const double kInf = 1e100;
const double kEps = 1e-12;
const int kEdgeMax = 500000;
const int kVtxMax = 20000;
inline double sgn(double x) {
	if ( fabs(x) < 1e-9 ) return 0;
	if ( x > 0 ) return 1;
	return -1;
}


struct Edge {
	double cap;
	int to;
	Edge *next, *inv;
} edge[kEdgeMax], *begin[kVtxMax];
int edgePtr=0;
int dist[kVtxMax];

Edge *makeEdge(int u, int v, double cap) {
	Edge *e = edge + edgePtr++;
	e->to = v, e->next = begin[u], e->cap = cap;
	return begin[u] = e;
}

void addEdge(int u, int v, double cap) {
	//fprintf(stderr, "%d->%d:%.2lf\n", u, v, cap);
	Edge *e1 = makeEdge(u, v, cap),
		 *e2 = makeEdge(v, u, 0);
	e1->inv = e2, e2->inv = e1;
}

bool relable(int src, int des, int nVtx) {
	static int Q[kVtxMax];
	memset(dist, -1, sizeof(int) * nVtx);
	dist[src] = 0;
	int qt = 0;
	Q[qt++] = src;
	for ( int qh = 0; qh < qt; qh ++ ) {
		int u = Q[qh];
		for ( Edge *e = begin[u]; e; e = e->next )
			if ( sgn(e->cap) ) {
				int v = e->to;
				if ( dist[v] != -1 )
					continue;
				dist[v] = dist[u] + 1;
				Q[qt++] = v;
			}
	}
	return dist[des]!=-1;
}

double findAug(int cur, int des, double flow) {
	if ( cur == des )
		return flow;
	double res = 0;
	Edge *e;
	for ( e = begin[cur]; e; e = e->next )
		if ( sgn(e->cap) ) {
			int v = e->to;
			if ( dist[v] == dist[cur] + 1 ) {
				double tmp = findAug(v, des, min(flow, e->cap));
				res += tmp;
				flow -= tmp;
				e->cap -= tmp;
				e->inv->cap += tmp;
				if ( !sgn(flow) )
					break;
			}
		}
	if ( !e )
		dist[cur] = -1;
	return res;
}

double dinic(int src, int des, int nVtx) {
	double res = 0;
	while ( relable(src, des, nVtx) ) 
		res += findAug(src, des, kInf);
	return res;
}


vector<string> weight;
int nRab;
int nVtx, src, sink;
int edgeIdx[55][55], rabIdx[55];

double solve();

class RabbitWorking {
	public:
		double getMaximum(vector <string> profit) {
			weight = profit;
			nRab = profit.size();
			return solve();
		}
};

void prework() {
	nVtx = 2;
	src = nVtx - 2, sink = nVtx - 1;
	for ( int i = 0; i < nRab; i ++ )
		rabIdx[i] = nVtx++;
	for ( int i = 0; i < nRab; i ++ )
		for ( int j = i + 1; j < nRab; j ++ )
			edgeIdx[i][j] = nVtx++;
}

double calcG(double lamda) {
	edgePtr = 0;
	memset(begin, 0, sizeof(begin));
	double sum = 0;
	for ( int i = 0; i < nRab; i ++ )
		for ( int j = i + 1; j < nRab; j ++ ) {
			addEdge(edgeIdx[i][j], rabIdx[i], kInf);
			addEdge(edgeIdx[i][j], rabIdx[j], kInf);
			double tmp = lamda * (weight[i][j] - '0') + 2;
			sum += tmp;
			addEdge(src, edgeIdx[i][j], tmp);
		}
	for ( int i = 0; i < nRab; i ++ )
		addEdge(rabIdx[i], sink, 199);

	return -(sum - dinic(src, sink, nVtx));
}

double solve() {
	prework();
	int maxWeight = 0;
	for ( int i = 0; i < nRab; i ++ )
		for ( int j = i + 1; j < nRab; j ++ )
			maxWeight = max(maxWeight, weight[i][j] - '0');
	if ( maxWeight == 0 ) 
		return 0;
	double lb = 0, rb = 2.0 * 198 / maxWeight;
	while ( rb - lb > kEps ) {
		double mid = (lb + rb) / 2;
		if ( sgn(calcG(mid)) >= 0 )
			lb = mid;
		else
			rb = mid;
	}
	return 1.0 / lb;
}


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, double p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	RabbitWorking *obj;
	double answer;
	obj = new RabbitWorking();
	clock_t startTime = clock();
	answer = obj->getMaximum(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = fabs(p1 - answer) <= 1e-9 * max(1.0, fabs(p1));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	double p1;

	{
		// ----- test 0 -----
		string t0[] = {"07666667666266666666666766666666667766677666666666", "70777777777377777777777777777777777777777777777777", "67066667666266666666666766666666667766677666666666", "67606667666266666666666766666666667766677666667666", "67660667666266666666666766666666667766677666667666", "67666067666266666666666766666666667766677666667666", "67666607666266666666666766666666667766677666666666", "77777770777377777777777777777777777777777777777777", "67666667066266666666666766666666667766677666667666", "67666667606266666666666766666666667766677666667666", "67666667660266666666666766666666667766677666667666", "23222223222022222222222222222222222222223222222222", "67666667666206666666666766666666667766677666667666", "67666667666260666666666766666666667766677666667666", "67666667666266066666666766666666667766677666667666", "67666667666266606666666766666666667766677666667666", "67666667666266660666666766666666667766677666666666", "67666667666266666066666766666666667766677666667666", "67666667666266666606666766666666667766677666666666", "67666667666266666660666766666666667766677666667666", "67666667666266666666066766666666667766677666666666", "67666667666266666666606766666666667766677666666666", "67666667666266666666660766666666667766677666667666", "77777777777277777777777077777777777777777777777777", "67666667666266666666666706666666667766677666667666", "67666667666266666666666760666666667766677666666666", "67666667666266666666666766066666667766677666666666", "67666667666266666666666766606666667766677666667666", "67666667666266666666666766660666667766677666667666", "67666667666266666666666766666066667766677666667666", "67666667666266666666666766666606667766677666667666", "67666667666266666666666766666660667766677666666666", "67666667666266666666666766666666067766677666667666", "67666667666266666666666766666666607766677666667666", "77777777777277777777777777777777770777777777777777", "77777777777277777777777777777777777077777777777777", "67666667666266666666666766666666667706677666666666", "67666667666266666666666766666666667760677666667666", "67666667666266666666666766666666667766077666667666", "77777777777277777777777777777777777777707777777777", "77777777777377777777777777777777777777770777777777", "67666667666266666666666766666666667766677066667666", "67666667666266666666666766666666667766677606667666", "67666667666266666666666766666666667766677660666666", "67666667666266666666666766666666667766677666067666", "67666667666266666666666766666666667766677666607666", "67677767777277776767667776677776777767777776770776", "67666667666266666666666766666666667766677666667066", "67666667666266666666666766666666667766677666667606", "67666667666266666666666766666666667766677666666660"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 1.0;
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
	}
	return 0;
	{
		// ----- test 1 -----
		string t0[] = {"061","602","120"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0.015228426395939087;
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 2 -----
		string t0[] = {"0"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0.0;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 3 -----
		string t0[] = {"013040","100010","300060","000008","416000","000800"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0.021996615905245348;
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
	}

	{
		// ----- test 4 -----
		string t0[] = {"06390061","60960062","39090270","96900262","00000212","00222026","66761201","12022610"};
		p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
		p1 = 0.06871794871794872;
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
